<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

		<title>Minigame</title>

		<!-- Babylon.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/ammo.js"></script>
		<script src="https://preview.babylonjs.com/cannon.js"></script>
		<script src="https://preview.babylonjs.com/Oimo.js"></script>
		<script src="https://preview.babylonjs.com/earcut.min.js"></script>
		<script src="https://preview.babylonjs.com/babylon.js"></script>
		<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
		<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
		<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
		<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
		<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
		<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
		<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

		<style>
			html, body {
				overflow: hidden;
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
			}

			#renderCanvas {
				width: 100%;
				height: 100%;
				touch-action: none;
			}
		</style>
	</head>
	<body>
		<canvas id="renderCanvas"></canvas>
    <script>
			var canvas = document.getElementById("renderCanvas");

      var globalBarrel = null;
			var engine = null;
			var scene = null;
			var sceneToRender = null;
      var inputMap = {};
      var globalHero = null;
      var radio = null;
      var hero = null;
      var barrel = null;
      var barrelbox = null;

			var createDefaultEngine = function() { 
				return new BABYLON.Engine(canvas, true, { 
					preserveDrawingBuffer: true, 
					stencil: true,  
					disableWebGL2Support: false
				}); 
			};

			const createScene =  () => {
				scene = new BABYLON.Scene(engine);
				
				/**** Set camera and light *****/
				const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 200, new BABYLON.Vector3(0, 0, 0));
				camera.attachControl(canvas, true);
				const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(4, 1, 0));
        camera.lowerRadiusLimit = 20;
        camera.upperRadiusLimit = 20;
        camera.wheelDeltaPercentage = 0.01;
        camera.upperBetaLimit = Math.PI / 2.2;
				createCenario();
        showGUIInstructions();
        createCharacter(camera);
        importRandomMeshes();
        importCollectableMeshes();
        setTimeout(() => { checkIntersaction(); }, 6000);

				return scene;
			}

			function createCenario()
			{
				// Creating the ground with texture
				const principalGround = BABYLON.MeshBuilder.CreateGroundFromHeightMap("principalGround", "assets/terrain.jpg", 
																																					{width:150, height:150, subdivisions: 40, minHeight:0, maxHeight: 20});
        const principalGroundMat = new BABYLON.StandardMaterial("principalGroundMat");
        principalGroundMat.diffuseTexture = new BABYLON.Texture("assets/snow.jpg");
        principalGround.material = principalGroundMat;
        principalGround.position.y = -0.5;

        // Creating skybox
        var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:150}, scene);
        var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
        skyboxMaterial.backFaceCulling = false;
        // In the path argument is the skybox images folder, and "skybox4" references all the 6 images that composes it
        skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("assets/skybox/skybox4", scene); 
        skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skyboxMaterial.disableLighting = true;
        skybox.material = skyboxMaterial;    
			}

      function showGUIInstructions()
      {
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var instructions = new BABYLON.GUI.TextBlock();
        instructions.text = "Move: WASD | Look arround: Mouse | Samba: B";
        instructions.color = "red";
        instructions.fontSize = 16;
        instructions.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER
        instructions.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM
        advancedTexture.addControl(instructions);
      }

      function createCharacter(camera)
      {
        scene.actionManager = new BABYLON.ActionManager(scene);
        scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
          inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
        }));
        scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
          inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
        }));
        
        globalHero = BABYLON.SceneLoader.ImportMesh("", "https://assets.babylonjs.com/meshes/", "HVGirl.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
          
          hero = newMeshes[0];
          //Scale the model down        
          hero.scaling.scaleInPlace(0.1);
          hero.position.x = 20;
          hero.position.y = -0.2;

          //Lock camera on the character 
          camera.target = hero;

          //Hero character variables 
          var heroSpeed = 0.1;
          var heroSpeedBackwards = 0.05;
          var heroRotationSpeed = 0.1;

          var animating = true;

          const walkAnim = scene.getAnimationGroupByName("Walking");
          const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
          const idleAnim = scene.getAnimationGroupByName("Idle");
          const sambaAnim = scene.getAnimationGroupByName("Samba");

          

          //Rendering loop (executed for everyframe)
          scene.onBeforeRenderObservable.add(() => {
            var keydown = false;
            //Manage the movements of the character (e.g. position, direction)
            if (inputMap["w"]) {
              hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
              keydown = true;
            }
            if (inputMap["s"]) {
              hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
              keydown = true;
            }
            if (inputMap["a"]) {
              hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
              keydown = true;
            }
            if (inputMap["d"]) {
              hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
              keydown = true;
            }
            if (inputMap["b"]) {
                keydown = true;
            }

            //Manage animations to be played  
            if (keydown) {
              if (!animating) {
                animating = true;
                if (inputMap["s"]) {
                  //Walk backwards
                  walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);
                }
                else if
                  (inputMap["b"]) {
                  //Samba!
                  sambaAnim.start(true, 1.0, sambaAnim.from, sambaAnim.to, false);
                }
                else {
                  //Walk
                  walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);
                }
              }
            }
            else {
              if (animating) {
                //Default animation is idle when no key is down     
                idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                //Stop all animations besides Idle Anim when no key is down
                sambaAnim.stop();
                walkAnim.stop();
                walkBackAnim.stop();

                //Ensure animation are played only once per rendering loop
                animating = false;
              }
            }
          });
        });
      }

      function importRandomMeshes()
      {
        // Importing barrel
        globalBarrel = BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "ExplodingBarrel.glb", scene, function (meshes) {
          barrel = meshes[0];
          barrel.scaling.scaleInPlace(0.02);
          barrel.position.x = 25;
          barrel.position.y = -0.15;
          barrelbox = BABYLON.MeshBuilder.CreateBox("barrelbox", {size:1}, scene);
          barrelbox.position.x = barrel.position.x;
          barrelbox.position.y = barrel.position.y;
          var mat = new BABYLON.StandardMaterial("mat", scene);
          mat.alpha = 0;
          barrelbox.material = mat;
        });        
        
        // Setting explode function for barrel
        globalBarrel.explosionSound = new BABYLON.Sound("explosion","assets/sound-effects/explosion.wav",scene, null, {volume: 0.07});

        globalBarrel.explosion = () => {
          BABYLON.ParticleHelper.CreateAsync("explosion", scene).then(
                  (set) => {
                    set.systems.forEach((s) => {
                      s.disposeOnStop = true;
                      s.emitter = new BABYLON.Vector3(25,-0.15,0);
                    });
                    set.start();
                  }
              );
              globalBarrel.explosionSound.play();
        }

        // Importing dragon
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/Georgia-Tech-Dragon/", "dragon.glb", scene, function (meshes) {
          var dragon = meshes[0];
          dragon.scaling.scaleInPlace(20);
          dragon.position.x = -20;
          dragon.position.y = -0.15;
          dragon.position.z = 4;          
        });
        
        // Importing house
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "haunted_house.glb", scene, function (meshes) {
          var house = meshes[0];
          house.scaling.scaleInPlace(60);
          house.position.x = 0;
          house.position.y = -0.15;
          house.position.z = -20;  
        });

        // Importing bird
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "seagulf.glb", scene, function (meshes) {
          var bird = meshes[0];
          bird.scaling.scaleInPlace(0.002);
          bird.position.x = -0.5;
          bird.position.y = 3.2;
          bird.position.z = 6;
        });

        // Importing plane
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/", "aerobatic_plane.glb", scene, function (meshes) { 
          var plane = meshes[0];
          plane.scaling.scaleInPlace(30);
          plane.position.x = 2;
          plane.position.y = 5;
          plane.position.z = 0;
        });
        
        // Importing fan
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/vintageDeskFan/", "vintageFan_animated.gltf", scene, function (meshes) {          
          var fan = meshes[0];
          fan.scaling.scaleInPlace(0.04);
          fan.position.x = -15;
          fan.position.y = 1.15;
          fan.position.z = -16;
        });

        // Importing ball
        BABYLON.SceneLoader.ImportMesh("", "https://models.babylonjs.com/shaderBall/", "BabylonShaderBall_Simple.gltf", scene, function (meshes) {          
          var ball = meshes[0];
          ball.scaling.scaleInPlace(0.5);
          ball.position.x = 20;
          ball.position.y = 1.5;
          ball.position.z = -16;
        });
      }
      
      function importCollectableMeshes()
      {
        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(20);
          radio.position.x = -5;
          radio.position.y = 1;
          radio.position.z = 25;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(30);
          radio.position.x = 0;
          radio.position.y = 1;
          radio.position.z = 30;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(40);
          radio.position.x = 5;
          radio.position.y = 1;
          radio.position.z = 21;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(50);
          radio.position.x = -10;
          radio.position.y = 1;
          radio.position.z = 15;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });
        
        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(60);
          radio.position.x = 15;
          radio.position.y = 1;
          radio.position.z = 18;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(70);
          radio.position.x = 20;
          radio.position.y = 1;
          radio.position.z = -5;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(80);
          radio.position.x = 15;
          radio.position.y = 2;
          radio.position.z = -15;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(90);
          radio.position.x = -15;
          radio.position.y = 1;
          radio.position.z = 0;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });

        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(100);
          radio.position.x = -17;
          radio.position.y = 1.5;
          radio.position.z = 15;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });
        
        BABYLON.SceneLoader.ImportMesh("", "objects/", "BoomBox.glb", scene, function (meshes) {
          radio = meshes[0];
          radio.scaling.scaleInPlace(110);
          radio.position.x = 1;
          radio.position.y = 1.5;
          radio.position.z = -15;
          radio.id = "radio";
          radio.rotationQuaternion = null;
        });
      }

      function checkIntersaction()
      {
        scene.registerBeforeRender(function () {
          if (hero.intersectsMesh(barrelbox, true))
          {
            if (barrel.isEnabled()){
              globalBarrel.explosion();
              barrel.setEnabled(false);
              barrelbox.setEnabled(false);
            }
          }
        });       
      }

			window.initFunction = async function() {               
				var asyncEngineCreation = async function() {
						try {
						return createDefaultEngine();
						} catch(e) {
						console.log("the available createEngine function failed. Creating the default engine instead");
						return createDefaultEngine();
						}
				}

				window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        window.scene = createScene();
			};

			initFunction().then(() => {sceneToRender = scene        
				engine.runRenderLoop(function () {
          if (sceneToRender && sceneToRender.activeCamera) {
            loop();
            sceneToRender.render();
          }
				});
			});

      function loop() {
        var radiomesh = scene.getMeshesByID("radio");
        var seed = 0;
        radiomesh.forEach(function (mesh) {
          mesh.rotation.y += 0.05;
        });
      };

			// Resize
			window.addEventListener("resize", function () {
					engine.resize();
			});
	</script>
</body>
</html>
