<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>
    <script>
      var canvas = document.getElementById("renderCanvas");

      var engine = null;
      var scene = null;
      var sceneToRender = null;
      var createDefaultEngine = function () {
        return new BABYLON.Engine(canvas, true, {
          preserveDrawingBuffer: true,
          stencil: true,
          disableWebGL2Support: false,
        });
      };
      var globalInstructionPanel;

      const createScene = () => {
        const scene = new BABYLON.Scene(engine);
        const panel = new BABYLON.GUI.StackPanel();
        scene.canPlay = true;
        setCamerasAndLights();
        scene.keys = createKeys(2, scene);
        eventManager(scene);
        createKFXMini25(scene);
        addDemos(scene);
        createGuiElements(panel, scene);

        return scene;
      };

      function createGuiElements(panel, scene) {
        // Label text
        var textBlock1 = new BABYLON.GUI.TextBlock();
        textBlock1.color = "white";
        textBlock1.text = "Felipe Eiji Maruyama 171150";
        textBlock1.height = "30px";
        var textBlock2 = new BABYLON.GUI.TextBlock();
        textBlock2.color = "white";
        textBlock2.text = "Para tocar as demos, pressione o botÃ£o 1 ou 2";
        textBlock2.height = "30px";
        var textBlock3 = new BABYLON.GUI.TextBlock();
        textBlock3.color = "white";
        textBlock3.text = "1: Undertale - Megalovania";
        textBlock3.height = "30px";
        var textBlock4 = new BABYLON.GUI.TextBlock();
        textBlock4.color = "white";
        textBlock4.text = "2: Still D.R.E. - Dr. Dre ft. Snoop Dogg";
        textBlock4.height = "30px";
        // Color panel
        var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI(
          "UI"
        );
        panel.width = "600px";
        panel.isVertical = true;
        panel.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
        panel.addControl(textBlock1);
        panel.addControl(textBlock2);
        panel.addControl(textBlock3);
        panel.addControl(textBlock4);
        advancedTexture.addControl(panel);
      }

      function addDemos(scene) {
        scene.onKeyboardObservable.add((kbInfo) => {
          switch (kbInfo.event.key) {
            case "1":
              if (scene.canPlay) {
                playDemo1(scene);
              }
              break;
            case "2":
              if (scene.canPlay) {
                playDemo2(scene);
              }
              break;
          }
        });
      }

      function createKFXMini25(scene) {
        const material = new BABYLON.StandardMaterial("kfxMaterial", scene);
        material.diffuseColor = new BABYLON.Color3(0, 0, 0);

        const keysBox = BABYLON.MeshBuilder.CreateBox("keysBox", {
          width: 0.21 * 16,
          height: 0.2,
          depth: 1.2,
        });
        keysBox.position.x = (0.21 * 16) / 2;
        keysBox.position.y = -0.2;
        keysBox.position.z += 0.1;
        keysBox.isPickable = false;
        keysBox.material = material;

        const leftSideBox = BABYLON.MeshBuilder.CreateBox("leftSideBox", {
          width: 0.21 / 2,
          height: 0.2,
          depth: 1.2,
        });
        leftSideBox.position.x = 0.21 * 16 - 0.21 / 4;
        leftSideBox.position.z += 0.1;
        leftSideBox.isPickable = false;
        leftSideBox.material = material;

        const rightSideBox = BABYLON.MeshBuilder.CreateBox("rightSideBox", {
          width: 0.21 / 2,
          height: 0.2,
          depth: 1.2,
        });
        rightSideBox.position.x = 0.21 / 4;
        rightSideBox.position.z += 0.1;
        rightSideBox.isPickable = false;
        rightSideBox.material = material;

        const topSideMaterial = new BABYLON.StandardMaterial("topSideMaterial");
        topSideMaterial.diffuseTexture = new BABYLON.Texture(
          "textures/topsidebox.PNG"
        );
        const topSideFaceUV = [];
        topSideFaceUV[0] = new BABYLON.Vector4(0.0, 0.0, 0.5, 0.5);
        topSideFaceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.5, 0.5);

        const topSideBox = BABYLON.MeshBuilder.CreateBox("topSideBox", {
          width: 0.21 * 15,
          height: 0.2,
          depth: 0.18,
          faceUV: topSideFaceUV,
          wrap: true,
        });
        topSideBox.position.x = (0.21 * 16) / 2;
        topSideBox.position.z += 0.61;
        topSideBox.isPickable = false;
        topSideBox.material = topSideMaterial;

        const kfxMaterial = new BABYLON.StandardMaterial("kfxMaterial");
        kfxMaterial.diffuseTexture = new BABYLON.Texture("textures/kfx.PNG");
        const kfxFaceUV = [];
        kfxFaceUV[0] = new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0);
        kfxFaceUV[2] = new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0);
        kfxFaceUV[3] = new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0);
        kfxFaceUV[5] = new BABYLON.Vector4(0.0, 0.0, 0.0, 0.0);

        const kfxBox = BABYLON.MeshBuilder.CreateBox("kfxBox", {
          width: 0.21 * 16,
          height: 0.2,
          depth: 1.2,
          faceUV: kfxFaceUV,
          wrap: true,
        });
        kfxBox.position.x = (0.21 * 16) / 2;
        kfxBox.position.y = -0.2;
        kfxBox.position.z += 1.3;
        kfxBox.isPickable = false;
        kfxBox.material = kfxMaterial;
      }

      function setCamerasAndLights() {
        const camera = new BABYLON.ArcRotateCamera(
          "camera",
          -Math.PI / 2,
          Math.PI / 2.5,
          4,
          new BABYLON.Vector3((0.21 * 16) / 2, 0, 0.5)
        );
        camera.attachControl(canvas, true);
        const light = new BABYLON.HemisphericLight(
          "light",
          new BABYLON.Vector3((0.21 * 16) / 2, 3, 0)
        );
      }

      function createKeys(numberOfSets, scene) {
        const keys = new Map();
        for (i = 0; i < numberOfSets; i++) {
          keys.set("do" + i, new Key("do", i, scene));
          keys.set("do#" + i, new Key("do#", i, scene));
          keys.set("re" + i, new Key("re", i, scene));
          keys.set("re#" + i, new Key("re#", i, scene));
          keys.set("mi" + i, new Key("mi", i, scene));
          keys.set("fa" + i, new Key("fa", i, scene));
          keys.set("fa#" + i, new Key("fa#", i, scene));
          keys.set("sol" + i, new Key("sol", i, scene));
          keys.set("sol#" + i, new Key("sol#", i, scene));
          keys.set("la" + i, new Key("la", i, scene));
          keys.set("la#" + i, new Key("la#", i, scene));
          keys.set("si" + i, new Key("si", i, scene));
        }
        keys.set("do" + numberOfSets, new Key("do", numberOfSets, scene));
        return keys;
      }

      class Key {
        constructor(noteName, octave, scene) {
          this.frameRate = 20;
          this.ySlide = new BABYLON.Animation(
            "ySlide",
            "rotation.x",
            this.frameRate,
            BABYLON.Animation.ANIMATIONTYPE_FLOAT,
            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
          );
          let keyFrames = [];

          keyFrames.push({
            frame: 0,
            value: 0,
          });

          keyFrames.push({
            frame: 0.05 * this.frameRate,
            value: -Math.PI / 30,
          });

          keyFrames.push({
            frame: 0.1 * this.frameRate,
            value: 0,
          });

          this.ySlide.setKeys(keyFrames);

          var naturalSize = 0.2;
          var sharpSize = 0.6 * naturalSize;
          var size;
          var naturalDepth = 1;
          var sharpDepth = 0.6 * naturalDepth;
          var depth;
          var distance = 0.01;
          var adjustedOctave = octave + 3;
          var fileName;
          var positionX;

          switch (noteName) {
            case "do":
              fileName = "c";
              positionX = 1;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "do#":
              fileName = "c-";
              positionX = 1;
              size = sharpSize;
              depth = sharpDepth;
              break;
            case "re":
              fileName = "d";
              positionX = 2;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "re#":
              fileName = "d-";
              positionX = 2;
              size = sharpSize;
              depth = sharpDepth;
              break;
            case "mi":
              fileName = "e";
              positionX = 3;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "fa":
              fileName = "f";
              positionX = 4;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "fa#":
              fileName = "f-";
              positionX = 4;
              size = sharpSize;
              depth = sharpDepth;
              break;
            case "sol":
              fileName = "g";
              positionX = 5;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "sol#":
              fileName = "g-";
              positionX = 5;
              size = sharpSize;
              depth = sharpDepth;
              break;
            case "la":
              fileName = "a";
              positionX = 6;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
            case "la#":
              fileName = "a-";
              positionX = 6;
              size = sharpSize;
              depth = sharpDepth;
              break;
            case "si":
              fileName = "b";
              positionX = 7;
              size = naturalSize;
              depth = naturalDepth;
              sharpSize = 0;
              break;
          }

          this.note = new BABYLON.Sound(
            noteName,
            "sounds/" + fileName + adjustedOctave + ".mp3",
            scene
          );

          this.box = BABYLON.MeshBuilder.CreateBox(noteName + octave, {
            height: size,
            width: size,
            depth: depth,
          });

          this.material = new BABYLON.StandardMaterial("keysMaterial", scene);

          this.box.position.x =
            (naturalSize + distance) * positionX +
            (naturalSize + distance) * 7 * octave;

          if (sharpSize) {
            this.box.position.z += naturalDepth * 0.2;
            this.box.position.y += naturalSize / 2;
            this.box.position.x += naturalSize / 2;
            this.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
          }

          this.box.material = this.material;

          this.box.setPivotPoint(new BABYLON.Vector3(0, 0, depth / 2));

          this.particleSystem = new BABYLON.ParticleSystem(
            "particles",
            150,
            scene
          );

          this.particleSystem.emitter = new BABYLON.Vector3(
            this.box.position.x,
            this.box.position.y + 0.15,
            this.box.position.z
          );
          this.particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, depth / 2);
          this.particleSystem.maxEmitBox = new BABYLON.Vector3(
            0,
            0,
            -depth / 2
          );

          this.particleSystem.particleTexture = new BABYLON.Texture(
            "textures/clef.png",
            scene
          );

          this.particleSystem.color1 = new BABYLON.Color4(0.99, 0.25, 0.03);
          this.particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);

          this.particleSystem.minSize = 0.1;
          this.particleSystem.maxSize = 0.5;

          this.particleSystem.minLifeTime = 0.03;
          this.particleSystem.maxLifeTime = 0.08;

          this.particleSystem.emitRate = 200;

          this.particleSystem.gravity = new BABYLON.Vector3(0, -400, 0);

          this.particleSystem.direction1 = new BABYLON.Vector3(-20, 80, 20);
          this.particleSystem.direction2 = new BABYLON.Vector3(20, 80, -20);

          this.particleSystem.minEmitPower = 0.1;
          this.particleSystem.maxEmitPower = 0.3;
          this.particleSystem.updateSpeed = 0.004;
        }

        play() {
          this.note.play();
          this.particleSystem.start();
          this.particleSystem.targetStopDuration = 0.07;
          scene.beginDirectAnimation(this.box, [this.ySlide], 0, 10, true);
        }
      }

      function eventManager(scene) {
        scene.onPointerDown = function (evt, pickResults) {
          if (pickResults.hit) {
            if (scene.canPlay)
              scene.keys.get(pickResults.pickedMesh.name).play();
          }
        };
      }

      async function playDemo1(scene) {
        scene.canPlay = false;
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("re1").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("la0").play();
        await new Promise((r) => setTimeout(r, 400));
        scene.keys.get("sol#0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 100));

        scene.keys.get("do0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("do0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("re1").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("la0").play();
        await new Promise((r) => setTimeout(r, 400));
        scene.keys.get("sol#0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 100));

        scene.keys.get("si0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("si0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("re1").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("la0").play();
        await new Promise((r) => setTimeout(r, 400));
        scene.keys.get("sol#0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 100));

        scene.keys.get("la#0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("la#0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("re1").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("la0").play();
        await new Promise((r) => setTimeout(r, 400));
        scene.keys.get("sol#0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 250));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 200));
        scene.keys.get("re0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("fa0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.keys.get("sol0").play();
        await new Promise((r) => setTimeout(r, 100));
        scene.canPlay = true;
      }

      async function playDemo2(scene) {
        scene.canPlay = false;
        for (let i = 0; i < 2; i++) {
          scene.keys.get("do1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("la1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("do1").play();
          await new Promise((r) => setTimeout(r, 500));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("la1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("si0").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("la1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("si0").play();
          await new Promise((r) => setTimeout(r, 500));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("la1").play();
          await new Promise((r) => setTimeout(r, 300));
          scene.keys.get("mi1").play();
          await new Promise((r) => setTimeout(r, 300));
        }
        for (let j = 0; j < 2; j++) {
          for (let i = 0; i < 8; i++) {
            scene.keys.get("do1").play();
            scene.keys.get("mi1").play();
            scene.keys.get("la1").play();
            await new Promise((r) => setTimeout(r, 300));
          }
          for (let i = 0; i < 3; i++) {
            scene.keys.get("si0").play();
            scene.keys.get("mi1").play();
            scene.keys.get("la1").play();
            await new Promise((r) => setTimeout(r, 300));
          }
          for (let i = 0; i < 5; i++) {
            scene.keys.get("si0").play();
            scene.keys.get("mi1").play();
            scene.keys.get("sol1").play();
            await new Promise((r) => setTimeout(r, 300));
          }
        }
        scene.canPlay = true;
      }

      var engine;
      var scene;
      initFunction = async function () {
        var asyncEngineCreation = async function () {
          try {
            return createDefaultEngine();
          } catch (e) {
            console.log(
              "the available createEngine function failed. Creating the default engine instead"
            );
            return createDefaultEngine();
          }
        };

        engine = await asyncEngineCreation();
        if (!engine) throw "engine should not be null.";
        scene = createScene();
      };
      initFunction().then(() => {
        sceneToRender = scene;
        engine.runRenderLoop(function () {
          if (sceneToRender && sceneToRender.activeCamera) {
            sceneToRender.render();
          }
        });
      });

      // Resize
      window.addEventListener("resize", function () {
        engine.resize();
      });
    </script>
  </body>
</html>
